{
  "1. Основные понятия теории графов: граф, степень вершины, висячая вершина, изолированная вершина, смежные вершины, полный граф, псевдограф, мультиграф, двудольный граф.": "*   **Граф**:\n    **Определение** Граф представляет собой **непустое конечное множество вершин V** и **ребер E**, оба конца которых принадлежат множеству V. Обозначать граф будем G(V,E) = <V,E>, где V ≠ ∅ и E ⊆ V × V. При изображении графов на рисунках или схемах ребра могут быть прямолинейными или криволинейными; длины ребер и расположение вершин произвольны. Число вершин графа G обозначается **p**, а число ребер – **q**.\n\n*   **Степень вершины**:\n    **Определение** **Степенью вершины** называется **число ребер графа, которым принадлежит эта вершина**. Степень графа еще называют его **валентностью** и обозначают d(υ) или deg(υ).\n    **Свойства степени вершины**:\n    1.  В графе G(V,E) **сумма степеней всех его вершин – число четное**, равное удвоенному числу ребер графа.\n    2.  **Число нечетных вершин** любого графа **четно**.\n    3.  Во всяком графе с n вершинами, где n ≥ 2, всегда найдутся, по меньшей мере, **две вершины с одинаковыми степенями**.\n    4.  Если в графе с n вершинами (n ≥ 2) в точности две вершины имеют одинаковую степень, то в графе всегда найдется либо в точности одна вершина степени 0, либо в точности одна вершина степени n − 1.\n\n*   **Висячая вершина**:\n    **Определение** Если d(υ) = 1, то вершина графа называется **висячей**.\n\n*   **Изолированная вершина**:\n    **Определение** Вершины, которые **не принадлежат ни одному ребру**, называют **изолированными**. Также, если d(υ) = 0, то вершина графа называется изолированной. Изолированная вершина не имеет петель и из нее не выходит ни одного ребра.\n\n*   **Смежные вершины**:\n    **Определение** **Две вершины, инцидентные одному ребру**, называются **смежными**.\n\n*   **Полный граф**:\n    **Определение** Граф называется **полным**, если **каждые две различные вершины его соединены одним и только одним ребром**.\n    **Свойство**: Степень любой вершины полного графа равна n − 1. Число ребер полного графа равно: K = n(n − 1)/2.\n\n*   **Псевдограф**:\n    **Определение** Граф, содержащий **петли** или **кратные (параллельные) ребра**, называется **псевдографом**. Петли – это ребра, соединяющие какую-либо вершину саму с собой.\n\n*   **Мультиграф**:\n    **Определение** **Псевдограф без петель** называется **мультиграфом**.\n\n*   **Двудольный граф**:\n    **Определение** Пусть множество V вершин графа G состоит из двух непустых множеств V1 и V2 так, что V = V1 ∪ V2 и V1 ∩ V2 = ∅. Если **каждое ребро графа G соединяет некоторую вершину множества V1 с какой-либо вершиной множества V2**, то такой граф называется **двудольным**.\n    **Определение (Полный двудольный граф)** Двудольный граф называется **полным**, если **каждая вершина множества V1 соединена с каждой вершиной множества V2**.\n    **Свойство**: Полный двудольный граф имеет k ребер, где k = |V1| · |V2|. Степень любой вершины множества V1 полного двудольного графа равна |V2|, а степень каждой вершины множества V2 равна |V1|.",
  "2. Способы задания неориентированных графов. Что такое матрица смежности и матрица инцидентности? Как по матрице смежности определить вид графа? Как по матрицам смежности и инцидентности определить степень вершины?": "*   **Способы задания графов**:\n    Графы могут быть заданы тремя способами:\n    1.  **Аналитический**\n    2.  **Графический или геометрический**\n    3.  **Матричный**\n\n*   **Матрица смежности**:\n    **Определение** **Матрица смежности** представляет собой **квадратную таблицу размерами n × n**, где n – число вершин графа. Строкам и колонкам матрицы ставятся в соответствие вершины, а на пересечениях строк и колонок записываются числа, показывающие, сколько ребер соединяют соответствующие вершины графа.\n    **Как по матрице смежности определить вид графа**:\n    *   Если в матрице кроме нулей и единиц нет никаких других чисел и всю главную диагональ занимают нули, то граф является **простым**.\n    *   Если во всей главной диагонали записаны нули, а в других позициях матрицы встречаются числа, превосходящие единицу, то граф является **мультиграфом**.\n    *   Если в главной диагонали имеются числа, не равные нулю, то граф содержит петли и, следовательно, является **псевдографом**.\n    **Как по матрице смежности определить степень вершины**:\n    Для этого достаточно **сложить все числа в соответствующей строке (или колонке)** и **добавить к результату число, находящееся на пересечении данной строки с главной диагональю** (т.е., если есть петли).\n\n*   **Матрица инцидентности**:\n    **Определение** **Матрица инцидентности** это матрица размерности n × m, где n – число вершин графа, m – число ребер графа, элементы которой определяются следующим образом:\n    `bij = { 1, если вершина xi инцидентна ребру υj; { 0, в противном случае; { 2, если петля;`\n    Матрица инцидентности является более информативной по сравнению с матрицей смежности, так как передает всю информацию о графе без каких-либо потерь.\n    **Как по матрице инцидентности определить степень вершины**:\n    Для определения степени вершины достаточно **найти сумму всех чисел какой-либо строки**. Эта сумма и будет равна степени соответствующей вершины.",
  "3. Операции над графами: дополнение, пересечение, объединение, сумма по модулю два. Что такое изоморфные графы.": "*   **Дополнение графа**:\n    **Определение** **Дополнением графа G1(V1,E1)** называется граф G1(V1,E1), множеством вершин которого является множество V1, а множество его ребер является множество E1 = {e ∈ V1 × V1 : e∉E1}.\n    **Свойство**: Дополнением полного графа на n вершинах является нуль-граф, а дополнением нуль-графа является полный граф.\n\n*   **Объединение графов**:\n    **Определение** **Объединением графов G1(V1,E1) и G2(V2,E2)** называют граф G(V,E) = G1(V1,E1) ∪ G2(V2,E2), где V = V1 ∪ V2; E = E1 ∪ E2.\n\n*   **Пересечение двух графов**:\n    **Определение** **Пересечением двух графов G1(V1,E1) и G2(V2,E2)** называют граф G(V,E) = G1(V1,E1) ∩ G2(V2,E2), где V = V1 ∩ V2; E = E1 ∩ E2.\n    **Свойство**: Если два графа не имеют одинаково обозначенных вершин, то их пересечение есть пустой граф.\n\n*   **Сумма по модулю два графов**:\n    **Определение** **Суммой по модулю два графов G1(V1,E1) и G2(V2,E2)** называют граф G(V,E) = G1(V1,E1) ⊕ G2(V2,E2), множеством вершин которого является множество V = V1 ∪ V2, а множеством его ребер – множество E = E1 ⊕ E2.\n    **Свойство**: Этот граф не имеет изолированных вершин и состоит только из ребер, присутствующих либо в первом графе, либо во втором графе, но не в обеих одновременно.\n\n*   **Изоморфные графы**:\n    **Определение** Изоморфизм (от греч. isos – равный, morphe – форма) – это соответствие между объектами, выражающее тождество их структуры.\n    Пусть даны два графа G1 и G2 с пронумерованными вершинами (помеченные графы). Такие графы называются **изоморфными**, если вершинам υi и υj, соединенным ребром в графе G1, соответствуют те же вершины, соединенные ребром в графе G2, и если вершинам υi и υj, не соединенным ребром в графе G1, соответствуют те же вершины, не соединенные ребром в графе G2 (i, j = 1, n, где n — число вершин).\n    **Пояснение**: Изоморфизм и равенство графов имеют много общего, но это не одно и то же. Неясности в основном связаны с различной нумерацией их вершин. Для того чтобы графы могли быть изоморфными, они должны иметь одинаковое число вершин с каждой степенью (0, 1, 2 и т.д.). Для установления изоморфизма необходимо пронумеровать вершины и проверить условия изоморфизма. В общем случае возможно до n! таких проверок.",
  "4. Основные понятия для связных графов: маршрут, цепь, простая цепь, замкнутая и разомкнутая цепь, цикл, связный и несвязный граф, степень связности, матрица расстояний, эксцентриситет вершин, радиус и диаметр графа.": "*   **Маршрут**:\n    **Определение** **Маршрутом длины n** называется непустая последовательность n ребер вида υ1, e1, υ2, e2, υ3, e3, . . . , υn, en, υn+1, где ребро ej (j = 1, n) соединяет вершины υj и υj+1. В маршруте одни и те же вершины могут повторяться.\n\n*   **Цепь**:\n    **Определение** Маршрут называется **цепью**, если в нем **нет повторяющихся ребер**.\n\n*   **Простая цепь**:\n    **Определение** Цепь называется **простой**, если в ней **нет повторяющихся вершин** (лишь первая и последняя вершины могут совпадать).\n    **Свойство**: Во всякой простой цепи число вершин на единицу больше числа ребер.\n\n*   **Замкнутая и разомкнутая цепь**:\n    Маршруты, цепи и простые цепи могут быть **замкнутыми** и **разомкнутыми**. В замкнутых маршрутах (а также цепях и простых цепях) начальная и конечная вершины совпадают, в разомкнутых — не совпадают.\n\n*   **Цикл**:\n    **Определение** **Замкнутая цепь** называется **циклом**.\n    **Определение (Простой цикл)** **Простая замкнутая цепь** называется **простым циклом**.\n    **Определение (Ациклический граф)** Граф без циклов называется **ациклическим**.\n\n*   **Связный и несвязный граф**:\n    **Определение** Две вершины υ и ω графа называются **связными**, если существует соединяющая их цепь.\n    **Определение** Граф называется **связным**, если **каждые две его вершины связны**.\n    **Определение** Если же в графе имеется хотя бы одна пара вершин, не соединенных цепью, то граф называется **несвязным**.\n    **Пояснение**: Отношение связности вершин является рефлексивным, симметричным, транзитивным, следовательно, множество связных вершин образует класс эквивалентности. Классы эквивалентности, из которых состоит несвязный граф, называются его **компонентами**.\n\n*   **Степень связности**:\n    **Определение** **Число компонент**, из которых состоит граф, называется **степенью связности**.\n\n*   **Матрица расстояний**:\n    **Определение** Пусть G(V,E) – связный граф; υ, ω – несовпадающие вершины. **Длина кратчайшего (υ, ω) – маршрута** называется **расстоянием** между вершинами υ и ω и обозначается через ρ(υ, ω), ρ(υ, υ) = 0.\n    Если V = {υ1, υ2, ..., υn}, то матрица P = (pij), в которой pij = ρ(υi, υj), называется **матрицей расстояний**. Матрица P симметрична (PT = P).\n\n*   **Эксцентриситет вершин**:\n    **Определение** Для фиксированной вершины υ величина **e(υ) = max{ρ(υ, ω)/ω ∈ V}** называется **эксцентриситетом вершины υ**.\n    **Свойство**: Если P – матрица расстояний, то эксцентриситет e(υi) равен наибольшему из чисел, стоящих в i-ой строке.\n\n*   **Радиус графа**:\n    **Определение** **Минимальный из эксцентриситетов** графа G называется его **радиусом** и обозначается **r(G)**: r(G) = min υ∈V {e(υ)}.\n    **Пояснение**: Вершина υ называется **центральной**, если e(υ) = r(G). Множество всех центральных вершин графа называется **центром**.\n\n*   **Диаметр графа**:\n    **Определение** **Максимальный среди всех эксцентриситетов** вершин называется **диаметром графа** и обозначается **d(G)**: d(G) = max υ∈V {e(υ)}.\n    **Пояснение**: Вершина υ называется **периферийной**, если e(υ) = d(G).",
  "5. Что такое обход графа. Рекурсивный и итеративный алгоритмы обхода графа в глубину. Алгоритм обхода графа в ширину. Реализация этих алгоритмов на С++ или Python.": "В предоставленных источниках **отсутствует информация** об обходе графа (понятия, алгоритмы в глубину и ширину, их рекурсивные и итеративные реализации, а также примеры кода на C++ или Python).",
  "6. Понятия эйлерова графа и цикла. Теорема Эйлера. Алгоритм нахождения эйлерова цикла. Реализация алгоритма на С++ или Python. Понятие уникурсальной линии.": "*   **Эйлеров цикл**:\n    **Определение** **Эйлеров цикл** – это **цикл в графе, который проходит через каждое ребро графа ровно один раз и возвращается в исходную вершину**. В честь Л. Эйлера его также называют эйлеровой линией, замкнутой эйлеровой цепью или просто эйлеровой цепью.\n\n*   **Эйлеров граф**:\n    **Определение** Граф, содержащий эйлеров цикл, получил название **эйлерова графа**.\n\n*   **Теорема Эйлера**:\n    **Теорема 1** (об эйлеровом цикле в неориентированном графе):\n    Если в связном графе **все вершины четны**, то этот граф содержит эйлеров цикл. Верно и обратное утверждение: если граф содержит эйлеров цикл, то все его вершины четны.\n    **Теорема 2** (об эйлеровой разомкнутой цепи):\n    Если в связном графе **две вершины нечетны**, а все остальные – четны, то этот граф содержит эйлерову разомкнутую цепь.\n    **Теорема 3** (о числе разомкнутых эйлеровых цепей):\n    Если в связном графе G содержится **2k нечетных вершин**, то в нем имеется **k разомкнутых эйлеровых цепей**, в совокупности содержащих все ребра графа G точно по одному разу.\n    **Теорема 4** (о замкнутом маршруте, проходящем через каждое ребро дважды):\n    В любом связном графе можно построить замкнутый маршрут, проходящий через каждое ребро точно два раза.\n\n*   **Алгоритм нахождения эйлерова цикла**:\n    Алгоритм можно разбить на несколько этапов:\n    **I. Проверка существования эйлерова цикла**:\n    1.  Граф должен быть **связным** (все вершины графа должны быть связаны между собой ребрами).\n    2.  **Степень каждой вершины графа должна быть четной** (каждая вершина должна иметь четное количество инцидентных ей ребер). Если хотя бы одна вершина имеет нечетную степень, эйлеров цикл не существует.\n    **II. Нахождение эйлерова цикла (с использованием стека)**:\n    1.  **Инициализация**: Создать пустой стек `st`, пустой вектор `eulerCycle`, выбрать стартовую вершину `v` и поместить ее в стек.\n    2.  **Поиск цикла**: Пока стек не пуст, взять вершину `v` с вершины стека. Искать смежную вершину `i`. Если найдена: добавить `i` в стек, удалить ребро `(v, i)` и перейти к `i`. Если смежных вершин нет: добавить `v` в `eulerCycle` и удалить `v` из стека.\n    3.  **Завершение**: После прохождения всех ребер графа убедиться, что путь замкнут.\n    4.  **Вывод результата**: Вывести найденный эйлеров цикл.\n\n*   **Реализация алгоритма на С++**:\n    Источники содержат пример реализации алгоритма нахождения эйлерова цикла на C++, который принимает количество вершин `n` и матрицу смежности графа, а затем выводит найденный цикл. В этой реализации используется стек для отслеживания пути и вектор для сохранения эйлерова цикла. Также есть проверка четности степеней всех вершин.\n\n*   **Понятие уникурсальной линии**:\n    **Определение** Всякую линию, которую можно провести, проходя по заданным участкам точно по одному разу, называют **уникурсальной**.\n    **Пояснение**: Применительно к эйлеровым графам, провести уникурсальную линию – это значит пройти по всем ребрам графа по одному разу, не отрывая карандаш от бумаги. Замкнутая уникурсальная линия соответствует эйлерову циклу, а разомкнутая – эйлеровой разомкнутой цепи. Разомкнутая уникурсальная линия всегда начинается с нечетной вершины и заканчивается в другой нечетной вершине.",
  "7. Понятия гамильтонова графа и цикла. Признаки определения гамильтонова цикла. Алгоритм определения гамильтонова цикла. Понятие полугамильтонова графа.": "*   **Гамильтонов цикл**:\n    **Определение** Всякий цикл, содержащий **по одному разу каждую вершину графа**, стали называть **гамильтоновой линией (гамильтоновым циклом)**.\n    **Пояснение**: Гамильтонов цикл не обязательно содержит все ребра графа. Гамильтоновым может быть только связный граф.\n\n*   **Гамильтонов граф**:\n    **Определение** Граф, содержащий гамильтонову линию, называется **гамильтоновым графом**.\n\n*   **Признаки определения гамильтонова цикла**:\n    Общий признак, при помощи которого для любого графа можно было бы определить наличие гамильтонова цикла, не найден. Задача проверки существования гамильтонова цикла является NP-полной. Однако для многих частных случаев такие признаки известны:\n    *   Если в графе есть **висячая вершина** (степень 1), то гамильтонов цикл **отсутствует**.\n    *   Если граф на n вершинах является **полным**, то в нем имеется гамильтонов цикл при **n ≥ 3**.\n    *   **Теорема Дирака (1952)**: Если в простом графе с n≥ 3 вершинами **deg(v) ≥ n/2** для любой вершины v, то граф G является гамильтоновым.\n    *   **Теорема Оре (1960)**: Если число вершин графа G n ≥ 3 и для любых двух несмежных вершин u и v выполняется неравенство **deg(u) + deg(v) ≥ n**, то граф G – гамильтонов.\n\n*   **Алгоритм определения гамильтонова цикла (Алгоритм перебора Робертса и Флореса)**:\n    Данный алгоритм основан на **стратегии обхода «в глубину»**.\n    1.  Создать **стек просмотренных вершин**.\n    2.  Взять **первую произвольную вершину** и занести ее в стек.\n    3.  Рассмотреть **смежную с ней вершину, не лежащую в стеке**. Если найдется, занести ее в стек и продолжать поиск с нее. \n    4.  Если у вершины нет подходящей смежной, **удалить ее из стека** и вернуться к предыдущей вершине в стеке (возврат с неудачей).\n    5.  Процесс продолжается, пока не будет найден цикл, проходящий через все n вершин, или пока не будут исчерпаны все варианты.\n\n*   **Понятие полугамильтонова графа**:\n    **Определение** Связный граф, содержащий **простую разомкнутую цепь, в которую входят все вершины графа**, называется **полугамильтоновым**.\n    **Свойство**: Всякий гамильтонов граф является полугамильтоновым.",
  "8. Понятия плоского графа, грани графа, планарного графа. Теорема Эйлера о плоских графов. Следствие из теоремы.": "*   **Плоский граф**:\n    **Определение** **Плоским** называется граф, **изображенный на плоскости так, что его ребра пересекаются только в вершинах**.\n\n*   **Грань графа**:\n    **Определение** **Гранью** называется **часть плоскости, ограниченная со всех сторон ребрами и не содержащая внутри себя ни вершин, ни ребер**.\n    **Свойство**: Любой плоский граф имеет внешнюю (бесконечную) грань. Всякая петля в графе образует отдельную грань.\n\n*   **Планарный граф**:\n    **Определение** Всякий **изоморфный плоскому граф** называется **планарным**, то есть граф называется планарным, если у него есть плоское изображение.\n    **Свойство**: Очевидно, что всякий плоский граф является планарным.\n\n*   **Теорема Эйлера о плоских графах**:\n    **Теорема** Пусть n – число вершин связного плоского графа G, r – число его ребер и q – число граней. Тогда: **n + q = r + 2**\n    Эта теорема была доказана Л. Эйлером в 1752 г..\n\n*   **Следствие из теоремы**:\n    **Следствие** Формула Эйлера распространяется и на многокомпонентные графы: **n + q = r + k + 1**, где k – число компонент несвязного графа.",
  "9. Гомеоморфные графы. Критерий Понтрягина-Куратовского.": "*   **Гомеоморфные графы**:\n    **Определение** **Два графа называются гомеоморфными, если существуют их подразбиения, являющиеся изоморфными**.\n    **Операция подразбиения ребра**: Это замена ребра, соединяющего две вершины υ и ω, простой цепью из двух ребер, инцидентных новой вершине t. В результате такой операции число вершин и число ребер графа увеличивается на единицу. Проще говоря, на ребре размещается новая вершина степени 2.\n    **Операция надразбиения (стягивания)**: Это обратная подразбиению операция. Заключается в удалении вершины степени 2 и соединении двух инцидентных ей ребер в одно.\n\n*   **Критерий Понтрягина-Куратовского**:\n    **Критерий** **Граф является планарным только в том случае, если он не содержит подграфов, гомеоморфных графам G5 и G3,3**.\n    **Пояснение**:\n    *   **G5** – это полный граф с пятью вершинами, который не является планарным.\n    *   **G3,3** – это полный двудольный граф с долями размера 3 (3 вершины в одной доле, 3 в другой), который также не является планарным.",
  "10. Понятия дерева, леса. 4 теоремы.": "*   **Лес**:\n    **Определение** **Несвязный граф, не содержащий циклов**, называется **лесом**.\n\n*   **Дерево**:\n    **Определение** **Связный граф, не содержащий циклов**, называется **деревом**.\n\n*   **4 теоремы**:\n    1.  **Теорема 1**: Всякое дерево содержит **n − 1 ребер**, где n – число вершин.\n    2.  **Теорема 2**: Всякий лес содержит **n−k ребер**, где k – число компонент связности.\n    3.  **Теорема 3**: Любые две вершины дерева соединены **точно одной простой цепью**.\n    4.  **Теорема 4**: Если в дереве любые две вершины соединить ребром, то в графе **появится один цикл**.",
  "11. Остовные деревья. Понятие цикломатического числа. Область применения. Постановка задачи о нахождении минимального остовного дерева. Алгоритм Крускала. Алгоритм Примы. Реализация алгоритмов на С++ или Python.": "*   **Остовное дерево**:\n    **Определение** **Остовным деревом (spanning tree)** связного неориентированного графа G на n вершинах будем называть **подмножество его ребер размера n − 1, не содержащее циклов**. Оно содержит все вершины графа G. Если граф G взвешенный, суммарный вес ребер остовного дерева называется **весом остовного дерева**.\n\n*   **Цикломатическое число**:\n    **Определение** Наименьшее число z, показывающее, сколько ребер необходимо удалить из графа, чтобы получить его остов, называется **цикломатическим числом**. Если n – число вершин, m – число ребер, k – число компонент, то **z = m − n + k**.\n\n*   **Область применения остовных деревьев**:\n    *   Разработка сетей (телефонных, компьютерных).\n    *   Строительство дорог.\n    *   Производство печатных плат.\n    *   Кластеризация и визуализация данных.\n\n*   **Постановка задачи о нахождении минимального остовного дерева (МОД)**:\n    **Задача** Дан связный, неориентированный взвешенный граф G(V, E). Требуется найти такой связный ациклический подграф T ⊆ G, содержащий все вершины V, чтобы суммарный вес его ребер был минимален. Такой подграф называется **минимальным остовным деревом**.\n\n*   **Алгоритм Крускала**:\n    **Принцип работы**: Алгоритм работает по \"жадной\" стратегии. \n    1. Все ребра графа сортируются по возрастанию их весов.\n    2. Создается лес, где каждая вершина - отдельное дерево.\n    3. Ребра просматриваются в порядке отсортированного списка. Если очередное ребро соединяет вершины из разных деревьев (компонент связности), оно добавляется в остов, а соответствующие деревья объединяются. \n    4. Процесс продолжается до тех пор, пока все вершины не окажутся в одном дереве (т.е. будет добавлено n-1 ребро).\n\n*   **Алгоритм Прима**:\n    **Принцип работы**: Алгоритм также \"жадный\", но он строит одно дерево, постепенно расширяя его. \n    1. Выбирается произвольная стартовая вершина и добавляется в остов.\n    2. На каждом шаге к остову добавляется **ребро наименьшего веса**, которое соединяет вершину из уже построенного остова с вершиной, еще не входящей в него.\n    3. Процесс повторяется, пока все вершины не будут добавлены в остов.\n\n*   **Реализация алгоритмов на С++ или Python**:\n    *   **Алгоритм Крускала**: Источники предоставляют **реализацию на С++**, использующую систему непересекающихся множеств (Disjoint Set Union) для эффективной проверки принадлежности вершин к разным компонентам.\n    *   **Алгоритм Прима**: Источники описывают процедуру построения минимального остовного дерева по алгоритму Прима пошагово с примером, но **не содержат готовой реализации на С++ или Python**.",
  "12. Ориентированные графы. Понятие дуги, орграфа, основания орграфа, смешенного графа. Степень вершин орграфа.": "*   **Дуга**:\n    **Определение** В ориентированном графе упорядоченной паре вершин (υ, ω) соответствует **ориентированное ребро**, которое называется **дугой**. Началом дуги является вершина υ, концом – вершина ω.\n\n*   **Орграф (ориентированный граф)**:\n    **Определение** Граф, содержащий **только дуги**, называется **ориентированным графом или орграфом**.\n\n*   **Основание орграфа**:\n    **Определение** Если в орграфе заменить все дуги неориентированными ребрами, получим граф, который называется **основанием данного орграфа**.\n\n*   **Смешанный граф**:\n    **Определение** Граф, содержащий **и дуги, и неориентированные ребра**, называется **смешанным графом**.\n\n*   **Степень вершин орграфа**:\n    **Определение** **Степень входа вершины** (полустепень захода) равна числу входящих в нее дуг. **Степень выхода вершины** (полустепень исхода) равна числу выходящих из нее дуг.\n    **Свойство**: Сумма степеней входа всех вершин равна сумме степеней выхода всех вершин, и обе эти суммы равны общему числу дуг в орграфе.\n    **Определение по матрице смежности**: Если орграф представлен матрицей смежности, то **степень выхода i-й вершины равна сумме всех чисел i-й строки матрицы**. **Степень входа i-й вершины равна сумме чисел i-й колонки матрицы**.",
  "13. Матрица смежности. Матрица инцидентности, матрица смежности дуг орграфа.": "*   **Матрица смежности орграфа**:\n    **Определение** **Матрица смежности орграфа** - это **квадратная матрица n-го порядка**, строки и столбцы которой соответствуют вершинам графа G. **Элементы a_ij матрицы равны числу дуг, идущих из i-ой вершины в j-ю**.\n    **Пояснение**: В отличие от матрицы смежности неориентированного графа, эта матрица, как правило, несимметрична (a_ij ≠ a_ji).\n\n*   **Матрица инцидентности орграфа**:\n    **Определение** **Матрица инцидентности орграфа** - это матрица размерности n × m, строки которой соответствуют вершинам, а столбцы - дугам графа. Элементы матрицы определяются следующим образом:\n    `b_ij = { -1, если дуга u_j исходит из i-ой вершины;`\n    `{  1, если дуга u_j заходит в i-ую вершину;`\n    `{  0, если дуга не инцидентна i-ой вершине;`\n\n*   **Матрица смежности дуг орграфа**:\n    **Определение** **Матрица смежности дуг орграфа** - это квадратная матрица m-го порядка (m - число дуг), строки и столбцы которой соответствуют дугам графа. Элементы матрицы определяются следующим образом:\n    `q_ij = { 1, если конец дуги u_i совпадает с началом дуги u_j;`\n    `{ 0, в остальных случаях;`",
  "14. Маршруты, цепи и циклы в орграфах. Достижимая вершина. Сильно связный, слабо связный, несвязный орграф.": "*   **Маршруты, цепи и циклы в орграфах**:\n    Определяются так же, как и в случае неориентированных графов, но **с учетом того, что движение возможно лишь в направлении дуг (стрелок)**.\n    **Определение (Ориентированная цепь)** Если в маршруте нет повторяющихся дуг, то маршрут называется **ориентированной цепью**.\n    **Определение (Простая ориентированная цепь)** Если в ориентированной цепи нет повторяющихся вершин, то такая цепь называется **простой ориентированной цепью**.\n    **Определение (Простой ориентированный цикл)** Замкнутая простая ориентированная цепь называется **простым ориентированным циклом**.\n\n*   **Достижимая вершина**:\n    **Определение** Вершина v_2 называется **достижимой** из вершины v_1, если **существует ориентированный маршрут, ведущий из вершины v_1 в вершину v_2**.\n\n*   **Сильно связный орграф**:\n    **Определение** Орграф называется **сильно связным**, если для любой упорядоченной пары вершин (u, v) существует ориентированный путь из u в v (т.е. v достижима из u, и u достижима из v).\n\n*   **Слабо связный орграф**:\n    **Определение** Орграф называется **слабо связным**, если его **основание (неориентированный граф, полученный заменой дуг ребрами) является связным графом**.\n\n*   **Несвязный орграф**:\n    **Определение** Орграф называется **несвязным**, если его основание является несвязным графом.",
  "15. Эйлерова цепь. Теорема о том, что орграф содержит замкнутую эйлерову цепь.": "*   **Эйлерова цепь (в орграфе)**:\n    **Определение** **Ориентированная замкнутая цепь**, содержащая **все дуги графа ровно по одному разу**, называется **эйлеровой** (или эйлеровым циклом).\n    **Пояснение**: Если ориентированная разомкнутая цепь содержит все дуги графа, то такая цепь называется **полуэйлеровой**.\n\n*   **Теорема о том, что орграф содержит замкнутую эйлерову цепь**:\n    **Теорема** Орграф содержит замкнутую эйлерову цепь тогда и только тогда, когда он является **слабо связным** и когда **для каждой его вершины степень входа равна степени выхода**.\n\n*   **Следствие из теоремы (для разомкнутой эйлеровой цепи)**:\n    Ориентированный граф содержит разомкнутую эйлерову цепь тогда и только тогда, когда он **слабо связный** и выполняются следующие условия:\n    *   существует **ровно одна вершина, у которой степень выхода на единицу больше степени входа** (это начало цепи);\n    *   существует **ровно одна вершина, у которой степень входа на единицу больше степени выхода** (это конец цепи);\n    *   у всех остальных вершин степень входа **равна степени выхода**.",
  "16. Взвешенный граф. Алгоритм. Постановка задачи нахождения кратчайших путей. Алгоритм Дейкстры. Алгоритм Флойда. Алгоритм Белмана-Форда. Реализация алгоритмов на С++ или Python.": "*   **Взвешенный граф**:\n    **Определение** Граф, каждому ребру (или дуге) которого поставлено в соответствие некоторое число (вес, длина, стоимость), называется **взвешенным** или **нагруженным**. Длина пути во взвешенном графе определяется как сумма весов ребер (дуг), входящих в этот путь.\n\n*   **Постановка задачи нахождения кратчайших путей**:\n    **Задача** Во взвешенном графе для заданной пары вершин (стартовой и конечной) или для одной стартовой вершины и всех остальных найти путь (или пути) с минимальной суммой весов ребер. \n\n*   **Алгоритм Дейкстры**:\n    **Назначение**: Находит **кратчайшие пути от одной (стартовой) вершины до всех остальных**.\n    **Ограничение**: Работает корректно только для графов с **неотрицательными весами ребер**.\n    **Принцип работы**: \"Жадный\" алгоритм. На каждом шаге выбирается еще не посещенная вершина с наименьшей известной длиной пути от старта и эта длина объявляется окончательной. Затем длины путей до всех соседей этой вершины обновляются (релаксируются).\n    **Сложность**: O(V²) при использовании матрицы смежности; O(E log V) при использовании очереди с приоритетами (для разреженных графов).\n    **Реализация**: Источники предоставляют **реализации алгоритма Дейкстры на C++** с использованием различных структур данных.\n\n*   **Алгоритм Флойда-Уоршелла**:\n    **Назначение**: Находит **кратчайшие пути между всеми парами вершин** в графе.\n    **Особенности**: Работает с **положительными и отрицательными весами ребер**, но не работает при наличии циклов отрицательного веса.\n    **Принцип работы**: Алгоритм динамического программирования. Он последовательно перебирает все вершины `k` и для каждой пары вершин `i, j` проверяет, не станет ли путь `i -> k -> j` короче, чем текущий известный путь `i -> j`.\n    **Сложность**: O(V³).\n    **Реализация**: Источники предоставляют **реализацию алгоритма Флойда на C++**.\n\n*   **Алгоритм Беллмана-Форда**:\n    **Назначение**: Находит **кратчайшие пути от одной (стартовой) вершины до всех остальных**.\n    **Особенности**: В отличие от Дейкстры, **корректно работает с ребрами отрицательного веса**. Также позволяет обнаружить наличие циклов отрицательного веса.\n    **Принцип работы**: Выполняет `V-1` итерацию, на каждой из которых пытается улучшить (релаксировать) длины путей через каждое ребро графа. Если после `V-1` итераций на `V`-й итерации все еще возможно улучшение, это свидетельствует о наличии цикла отрицательного веса.\n    **Сложность**: O(V * E).\n    **Реализация**: **Реализации алгоритма на C++ или Python в источниках не представлены**.",
  "17. Постановка задача коммивояжера. Виды задач коммивояжера. Алгоритмы решения задачи.": "*   **Постановка задачи коммивояжера (Traveling Salesman Problem, TSP)**:\n    **Задача**: Дан полный взвешенный граф. Требуется найти **гамильтонов цикл с минимальным возможным весом**. Иными словами, необходимо найти такой маршрут, который начинается в некотором городе, проходит через все остальные города ровно по одному разу и возвращается в исходный город, при этом суммарная длина пути должна быть минимальной.\n    **Пояснение**: Задача коммивояжера является одной из самых известных NP-полных задач комбинаторной оптимизации.\n\n*   **Виды задач коммивояжера**:\n    Хотя в предоставленных источниках не выделяются конкретные виды, в общем случае задачу разделяют на:\n    *   **Симметричную**: Вес ребра `(u, v)` равен весу ребра `(v, u)` для всех пар вершин. Граф неориентированный.\n    *   **Асимметричную**: Веса ребер `(u, v)` и `(v, u)` могут быть разными. Граф ориентированный.\n    Также существуют вариации, где выполняется неравенство треугольника `(вес(u, w) <= вес(u, v) + вес(v, w))` и где не выполняется.\n\n*   **Алгоритмы решения задачи**:\n    Из-за NP-полноты задачи, не существует алгоритма, решающего ее за полиномиальное время. Основные подходы:\n    *   **Точные алгоритмы**: Гарантируют нахождение оптимального решения, но имеют экспоненциальную сложность. Применимы только для небольшого числа городов. Пример: метод полного перебора (сложность O(n!)), метод ветвей и границ, динамическое программирование (алгоритм Хелда-Карпа, O(n² * 2^n)).\n    *   **Приближенные (эвристические) алгоритмы**: Находят хорошее, но не обязательно оптимальное решение за приемлемое время. Примеры: метод ближайшего соседа, метод включения, алгоритм Кристофидеса (для метрической задачи), генетические алгоритмы, метод имитации отжига.\n    **В предоставленных источниках конкретные алгоритмы, кроме неэффективного полного перебора, не описываются.**",
  "18. Постановка задачи о максимальном потоке. Алгоритм решения задачи.": "*   **Постановка задачи о максимальном потоке**:\n    **Задача**: Дана транспортная сеть, которая представляется в виде ориентированного графа. Каждая дуга графа имеет **пропускную способность** — максимальное количество \"потока\" (товара, данных, жидкости), которое может пройти по ней в единицу времени. В сети выделены две вершины: **исток (source)**, из которого поток выходит, и **сток (sink)**, в который поток входит. Требуется найти **максимально возможную величину потока**, который можно направить из истока в сток, соблюдая ограничения пропускной способности дуг и условие сохранения потока (для всех промежуточных вершин входящий поток равен выходящему).\n\n*   **Алгоритм решения задачи**:\n    Классическим методом решения задачи является **алгоритм Форда — Фалкерсона**. \n    **Идея алгоритма**: Начинаем с нулевого потока. На каждой итерации ищем в остаточной сети (графе, показывающем доступные пропускные способности) любой **увеличивающий путь** из истока в сток. Если такой путь найден, мы увеличиваем поток вдоль этого пути на минимальную остаточную пропускную способность среди всех дуг этого пути. Затем обновляем остаточную сеть. Алгоритм завершается, когда увеличивающий путь из истока в сток найти больше невозможно. Величина потока на этот момент является максимальной. Эффективность алгоритма сильно зависит от способа поиска увеличивающего пути (например, алгоритм Эдмондса-Карпа использует поиск в ширину)."
}