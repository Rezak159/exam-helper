{
  "Вопрос 1: Что такое регулярные выражения и каковы примеры их использования?": "Регулярные выражения (Regular expressions) – это формальный язык, используемый в компьютерных программах для поиска и манипуляций с подстроками в тексте. Он основан на использовании метасимволов (символов-джокеров). Для поиска используется строка-образец (шаблон, маска), состоящая из символов и метасимволов, которая задает правило поиска. Для манипуляций с текстом дополнительно задается строка замены, также способная содержать специальные символы. Регулярные выражения представляют собой мощное, гибкое и эффективное средство для обработки текстов.\n\nПримеры использования регулярных выражений:\n1. Поиск или замена подстрок с нечетко обозначенными данными (например, поиск email-адресов и ссылок на веб-странице).\n2. Проверка сведений формы (валидация): валидация электронной почты, пароля, телефонного номера, паспортных данных и т.д.\n3. Формирование новых структур данных из строк или получение части строки (например, подсчет числа ключевых слов в тексте страницы без учета окончаний падежей).\n4. Подготовка и обработка данных: корректировка предварительных данных в текстовом редакторе.\n5. Создание программного кода с большим числом повторяющихся конструкций.\n6. Поиск отдельных фрагментов кода и их гибкая замена новыми (например, найти все последовательности символов «кот», найти отдельно стоящее слово «кот» и заменить его на «кошка», убрать из текста все предложения с упоминанием «кот» или «кошка»).\n7. Применение на разных этапах работы с рекламой: для сбора семантики, настройки сегментов, настройки аналитики на сайте и работы с отчетами (в Google Analytics, Яндекс.Метрике, Google Tag Manager, Wordstat, Key Collector, Excel и Google Таблицах).",
  "Вопрос 2: Каков синтаксис регулярных выражений?": "Регулярные выражения строятся по определенным правилам. Символы могут быть обычными (буквы, цифры) или специальными (метасимволами), которые используются для задания шаблона строки. Специальные символы необходимо экранировать, добавляя перед ними обратный слэш `\\`.\n\n**Основные специальные символы (метасимволы) и их значения:**\n*   ` . ` (точка): Обозначает один произвольный символ.\n*   ` [ ] ` (квадратные скобки): Заключают в себя набор символов, из которых допустимо лишь одно вхождение одного символа в строку.\n*   ` ^ ` (крышка): Указывает, что следующий за ним набор символов должен находиться в начале строки.\n*   ` [^ ] ` (крышка в квадратных скобках): Все символы, находящиеся после `^` внутри квадратных скобок, исключаются из шаблона.\n*   ` - ` (дефис): Используется для задания диапазона внутри квадратных скобок (например, `[0-9]` для цифр).\n*   ` $ ` (доллар): Указывает на то, что предшествующие ему элементы должны быть в конце строки.\n*   ` * ` (звездочка): Указывает на произвольное число повторений предшествующего символа (0 или более повторений).\n*   ` + ` (плюс): Указывает на одно или несколько повторений предыдущего символа.\n*   ` ? ` (вопросительный знак): Указывает, что предшествующий символ может либо отсутствовать, либо присутствовать в строке (0 или 1 повторение).\n*   ` ( ) ` (круглые скобки): Нужны для объединения группы элементов в один символ.\n*   ` | ` (прямой слэш): Означает логическую операцию ИЛИ.\n*   ` { } ` (фигурные скобки): Используются для указания конкретного количества повторений: `{min,max}`, `{min,}`, `{точное количество}`.\n\n**Сокращения для обозначения символов (классы символов):**\n*   `\\w`: Соответствует буквенно-цифровым символам `[a-zA-Z0-9_]`.\n*   `\\W`: Соответствует небуквенно-цифровым символам `[^\\w]`.\n*   `\\d`: Соответствует цифрам `[0-9]`.\n*   `\\D`: Соответствует нецифровым знакам `[^\\d]`.\n*   `\\s`: Соответствует знаку пробела `[\\t\\n\\f\\r\\v]`.\n*   `\\S`: Соответствует символам без пробела `[^\\s]`.",
  "Вопрос 3: Как использовать регулярные выражения в C++? Опишите функции regex_match(), regex_search() и regex_replace.": "Для использования регулярных выражений в C++ необходимо подключить стандартную библиотеку `<regex>`.\n\n1. **`std::regex_match()`**\n   - **Назначение**: Проверяет соответствие *всей последовательности символов* регулярному выражению.\n   - **Возвращаемое значение**: Возвращает `true`, если заданное выражение полностью соответствует строке, в противном случае — `false`.\n   - **Аргументы**: Строка для поиска, объект `regex` с выражением, необязательные флаги.\n\n2. **`std::regex_search()`**\n   - **Назначение**: Используется для поиска *шаблона в строке*, который соответствует регулярному выражению (необязательно всей строки).\n   - **Аргументы**: Строка для поиска, объект `smatch` для результатов, объект `regex` с выражением, необязательные флаги.\n   - **Объект `smatch`**: Хранит результаты поиска. Позволяет получить доступ к совпадениям (`res[i]`, `res.str(i)`), их количеству (`res.size()`), длине (`res.length(i)`), позиции (`res.position(i)`), а также к частям строки до (`res.prefix()`) и после (`res.suffix()`) совпадения.\n\n3. **`std::regex_replace()`**\n   - **Назначение**: Производит поиск в строке по заданному регулярному выражению и заменяет найденные значения на заданную строку.\n   - **Аргументы**: Строка для поиска, объект `regex` с выражением, строка для замены, необязательные флаги.",
  "Вопрос 4: Что такое префикс, суффикс, собственный префикс или суффикс, и префикс-функция? Как вычислять префикс-функцию для произвольной строки?": "**Префикс**: это подстрока, начинающаяся в начале строки.\n**Суффикс**: это подстрока, заканчивающаяся в конце строки.\n**Собственный префикс или суффикс**: это префикс или суффикс, который не совпадает с самой строкой.\n\n**Префикс-функция `π(S, i)`** от строки `S` и позиции `i` в ней – это длина `k` наибольшего *собственного* префикса подстроки `S[1..i]`, который одновременно является суффиксом этой подстроки. То есть, `S[1..k] = S[(i-k+1)..i]` и `k < i`. Принято считать, что `π(S, 1) = 0`.\n\n**Пример вычисления для строки `S = \"abcabcd\"`:**\n*   `a`: 0\n*   `ab`: 0\n*   `abc`: 0\n*   `abca`: 1 (префикс `a`)\n*   `abcab`: 2 (префикс `ab`)\n*   `abcabc`: 3 (префикс `abc`)\n*   `abcabcd`: 0\n\n**Алгоритм вычисления префикс-функции:**\n1. Создается вектор `p` размером с длину строки.\n2. Первый элемент `p[0]` всегда равен 0.\n3. Итерируем по строке с `i = 1`. Используем переменную `j` для отслеживания длины текущего префикса-суффикса (изначально `j=0`).\n4. Если символ `str[i]` совпадает с `str[j]`, то `p[i] = j + 1`, и обе переменные `i` и `j` увеличиваются.\n5. Если символы не совпадают (`str[i] != str[j]`):\n   - Если `j` равен 0, значит нет общего префикса-суффикса, `p[i]` устанавливается в 0, `i` увеличивается.\n   - Если `j` не равен 0, мы \"сдвигаемся\" к предыдущему возможному префиксу-суффиксу, устанавливая `j = p[j - 1]`, и повторяем сравнение.",
  "Вопрос 5: Опишите алгоритм работы Кнута-Морриса-Пратта.": "Алгоритм Кнута-Морриса-Пратта (КМП) – это эффективный алгоритм для поиска всех вхождений подстроки (прототипа) в исходном тексте. Он работает за линейное время `O(длина прототипа + длина текста)` и основывается на использовании префикс-функции.\n\n**Идея алгоритма:**\nИдея заключается в том, чтобы не начинать сравнение заново при каждом несовпадении символов, а использовать информацию о структуре уже просмотренной части текста. Для этого вычисляется префикс-функция для конкатенированной строки, состоящей из прототипа `p`, специального символа-разделителя `#` (который не встречается ни в `p`, ни в тексте `s`) и самого текста `s`. Получается строка вида `p + \"#\" + s`.\n\nРазделитель `#` гарантирует, что значения в массиве префикс-функции не превысят длину прототипа. При вычислении префикс-функции для этой объединенной строки, те позиции, где значение префикс-функции равно длине прототипа, соответствуют **концам вхождений** прототипа в исходном тексте.\n\nЧтобы найти **начальные позиции вхождения** подстроки, необходимо пройти по массиву префикс-функции. Если для индекса `i` (в объединенной строке) значение префикс-функции `p[i]` равно длине прототипа, то это означает, что найдено вхождение. Начало этого вхождения в исходной строке вычисляется по формуле: `i - 2 * длина_прототипа` (при индексации с 0) или `i - (длина_прототипа + 1) - длина_прототипа + 1` (при индексации с 1).",
  "Вопрос 6: Алгоритм работы Кнута-Морриса-Пратта. Уметь писать код на С++.": "Таким образом, на основе предоставленных материалов невозможно дать подробный ответ на ваш запрос."
}